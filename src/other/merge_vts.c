//
// Created by huach on 16/6/2023.
//


/*
 * this file is used to reduce the file number generated by salec2d
 * the *.vts belong to a same timestep will be put into a multi-DataSet vtm
 * when the large number of files transferred through net, the speed is usually very slow.
 *
 *  the previous version try to use the vtkXMLPStructuredGridReader and vtkXMLStructuredGridReader
 *  but the load/merge process is too slow, so we give up using the vtk api and just
 *  copy the different DataSet spread in *.vts file into a single *.vtm file.
 */

#include "output.h"
#include "sale2d.h"
#include <omp.h>

char * _strnstr(char *str, const char *substr, size_t n)
{
    char *p = str, *pEnd = str+n;
    size_t substr_len = strlen(substr);
    size_t str_len = strlen(str);
    if(0 == substr_len || 0 == str_len) return str;
    if(n > str_len) pEnd = str + str_len;

    pEnd -= (substr_len - 1);
    for(;p < pEnd; ++p)
    {
        if(0 == strncmp(p, substr, substr_len))
            return p;
    }
    return NULL;
}

char * _strncasestr(char *str, const char *substr, size_t n)
{
    char *p = str, *pEnd = str+n;
    size_t substr_len = strlen(substr);
    size_t str_len = strlen(str);
    if(0 == substr_len || 0 == str_len) return str;
    if(n > str_len) pEnd = str + str_len;

    pEnd -= (substr_len - 1);
    for(;p < pEnd; ++p)
    {
        if(0 == strncasecmp(p, substr, substr_len))
            return p;
    }
    return NULL;
}

int copy_vtk_file(FILE * src, FILE * dest)
{
    char * lineptr = NULL;
    size_t linelen = 0;
    int vtk_found = 0;
    size_t num_copy_line = 0;
    while(-1 != getline(&lineptr,&linelen,src))
    {
        if(NULL != _strnstr(lineptr,"VTKFile",10))
        {

            if(vtk_found)
            {
                break;
            }
            else
            {
                vtk_found = 1;
                continue;
            }
        };

        if(vtk_found)
        {
            fputs(lineptr,dest);
            num_copy_line++;
        }
    }
    free(lineptr);
    return num_copy_line;
}


int add_file(FILE * dest,const char * name)
{
    // copy a small file into dest
    // start with #BEGINFILE:<file-name>
    // end with #ENDFILE
    FILE * fp = fopen(name,"r");
    char * lineptr = NULL;
    size_t linelen = 0;
    int num_copy_line = 0;
    fprintf(dest,"#BEGINFILE:%s\n",name);
    while(-1 != getline(&lineptr,&linelen,fp))
    {
        fputs(lineptr,dest);
        num_copy_line++;
    }
    fputs("#ENDFILE\n",dest);
    fclose(fp);
    free(lineptr);
    return num_copy_line;
}

int extract_file(FILE * src, const char * dir)
{
    // extract small data
    char * lineptr = NULL;
    size_t linelen = 0;
    FILE * dest = NULL;
    int f_begin = 0;
    int num_file_extract = 0;
    while(-1 != getline(&lineptr,&linelen,src))
    {
        if(0 == strncasecmp(lineptr,"#BEGINFILE:",11))
        {
            f_begin = 1;
            dest = fopen(lineptr + 11,"w");
            if(NULL == dest)
            {
                fprintf(stderr,"cannot create %s\n",lineptr + 11);
                exit(0);
            }
            continue;
        }

        if(0 == strncasecmp(lineptr,"#ENDFILE",8))
        {
            f_begin = 0;
            fclose(dest);
            dest = NULL;
            num_file_extract ++;
        }

        if(f_begin) fputs(lineptr,dest);
    }
    return num_file_extract;
}


int create_vtm_block(int argc, char * argv[])
{
    char inpfile[256];
    if(argc == 1)
    {
        sprintf(inpfile,"../sale2d.inp");
    }
    else if(argc == 2)
    {
        sprintf(inpfile,"%s",argv[1]);
    } else
    {
        fprintf(stderr,"invalid args for salec2d.\n");
        exit(0);
    }

    InputFile * ifp = OpenInputFile(inpfile);
    mesh2d_info minfo;

    // create the dir to put vts merged
    make_empty_dir("mvts");

    // get the prefix
    char prefix[MaxStrLen];
    GetValueS(ifp, "output.prefix", prefix, "ParaTest");
    int npgx,npgy;
    npgx = GetValueI(ifp,"processor.npgx","2");
    npgy = GetValueI(ifp,"processor.npgy","2");
    const char *vts_name_format = "./vts/%s.proc%04d.%04d.vts";
    const char *mvts_name_format = "./mvts/%s.%04d.vts";
    char vts_name[MaxStrLen];
    char mvts_name[MaxStrLen];

    int MaxCycle = 10;
    int MinCycle = 8;

    for(int cycles = MinCycle; cycles < MaxCycle; ++cycles)
    {
        sprintf(mvts_name,mvts_name_format,prefix,cycles);
        FILE * mvts_fp = fopen(mvts_name,"w");
        fputs("<?xml version=\"1.0\"?>\n",mvts_fp);
        fputs("<VTKFile type=\"vtkMultiBlockDataSet\" version=\"0.1\" compressor=\"vtkZLibDataCompressor\" byte_order=\"LittleEndian\">\n",mvts_fp);
        fputs("  <vtkMultiBlockDataSet>\n",mvts_fp);
        for(int rank=0;rank<npgx*npgy;++rank)
        {
            sprintf(vts_name,vts_name_format,prefix,rank,cycles);
            FILE * vts_fp = fopen(vts_name,"r");
            if(vts_fp == NULL)
            {
                fprintf(stderr,"cannot open %s\n",vts_name);
                exit(0);
            }
            fprintf(mvts_fp,"    <DataSet index=\"%d\">\n",rank);
            copy_vtk_file(vts_fp,mvts_fp);
            fputs("    </DataSet>\n",mvts_fp);
            fclose(vts_fp);
        }
        fputs("  </vtkMultiBlockDataSet>\n",mvts_fp);
        fputs("</VTKFile>\n",mvts_fp);
        fclose(mvts_fp);
    }

    CloseInputFile(ifp);
}

int main(int argc, char * argv[])
{
    char inpfile[256];
    if(argc == 1)
    {
        sprintf(inpfile,"../sale2d.inp");
    }
    else if(argc == 2)
    {
        sprintf(inpfile,"%s",argv[1]);
    } else
    {
        fprintf(stderr,"invalid args for salec2d.\n");
        exit(0);
    }

    InputFile * ifp = OpenInputFile(inpfile);
    // create the dir to put vts merged
    make_empty_dir("mvts");

    // get the prefix
    char prefix[MaxStrLen];
    GetValueS(ifp, "output.prefix", prefix, "ParaTest");
    int npgx,npgy;
    npgx = GetValueI(ifp,"processor.npgx","2");
    npgy = GetValueI(ifp,"processor.npgy","2");
    CloseInputFile(ifp);

    const char *vts_name_format = "./vts/%s.proc%04d.%04d.vts";
    const char *mvts_name_format = "./mvts/%s.%04d.vts";

    int MaxCycle = 387;
    int MinCycle = 0;

//#pragma omp parallel for num_threads(4) shared(vts_name_format,mvts_name_format) default(none)
//    for(int cycles = MinCycle; cycles < MaxCycle; ++cycles)
//    {
//        char vts_name[MaxStrLen];
//        char mvts_name[MaxStrLen];
//        sprintf(mvts_name,mvts_name_format,prefix,cycles);
//        FILE * mvts_fp = fopen(mvts_name,"w");
//
//        for(int rank=0;rank<npgx*npgy;++rank)
//        {
//            sprintf(vts_name,vts_name_format,prefix,rank,cycles);
//            add_file(mvts_fp,vts_name);
//        }
//        fclose(mvts_fp);
//        fprintf(stdout,"write %s\n",mvts_name);
//    }

    #pragma omp parallel num_threads(4) default(shared)
    {
        int tid = omp_get_thread_num();
        int tid_num = omp_get_num_threads();

        int pack_num = 0;
        char pack_name[200];
        sprintf(pack_name,"./mvts/%s.vts.pack%04d.%04d",prefix,tid,pack_num);
        FILE * pack_fp = fopen(pack_name,"w");
        if(NULL == pack_fp)
        {
            fprintf(stderr,"cannot open %s\n",pack_name);
        }

        int cycles_num = (MaxCycle - MinCycle)/tid_num + 1;
        int cycles_start = MinCycle + tid*cycles_num;
        int cycles_end = MinCycle + (tid+1)*cycles_num;

        #pragma omp critical
        {
            fprintf(stdout,"thread %d/%d: on files interval [%04d,%04d)\n",tid,tid_num,cycles_start, MIN(cycles_end,MaxCycle));
        }

        for(int cycles = cycles_start; cycles < cycles_end && cycles < MaxCycle; ++cycles)
        {
            char vts_name[MaxStrLen];
            for(int rank=0;rank<npgx*npgy;++rank)
            {
                sprintf(vts_name,vts_name_format,prefix,rank,cycles);
                add_file(pack_fp,vts_name);
            }
            fprintf(stdout,"write cycle(%d) in %s\n",cycles,pack_name);
        }
        fclose(pack_fp);
    }

    return 0;
}